<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:tracking="http://www.mulesoft.org/schema/mule/ee/tracking" xmlns:metadata="http://www.mulesoft.org/schema/mule/metadata" xmlns:dw="http://www.mulesoft.org/schema/mule/ee/dw"
	xmlns:scripting="http://www.mulesoft.org/schema/mule/scripting"
	xmlns:json="http://www.mulesoft.org/schema/mule/json"
	xmlns:CiscoSpark="http://www.mulesoft.org/schema/mule/CiscoSpark" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns:db="http://www.mulesoft.org/schema/mule/db" xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns:spring="http://www.springframework.org/schema/beans" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.mulesoft.org/schema/mule/json http://www.mulesoft.org/schema/mule/json/current/mule-json.xsd
http://www.mulesoft.org/schema/mule/CiscoSpark http://www.mulesoft.org/schema/mule/CiscoSpark/current/mule-CiscoSpark.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/db http://www.mulesoft.org/schema/mule/db/current/mule-db.xsd
http://www.mulesoft.org/schema/mule/ee/dw http://www.mulesoft.org/schema/mule/ee/dw/current/dw.xsd
http://www.mulesoft.org/schema/mule/scripting http://www.mulesoft.org/schema/mule/scripting/current/mule-scripting.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/ee/tracking http://www.mulesoft.org/schema/mule/ee/tracking/current/mule-tracking-ee.xsd">
    <http:listener-config name="HTTP_Listener_Configuration" host="192.168.1.168" port="8844" doc:name="HTTP Listener Configuration"/>
    <http:request-config name="HTTP_Request_Configuration" host="183.82.99.100" port="7080" doc:name="HTTP Request Configuration"/>
    <CiscoSpark:config name="CiscoSpark__Configuration" doc:name="CiscoSpark: Configuration"/>
    <http:request-config name="HTTP_Request_Configuration1" protocol="HTTPS" host="*.zendesk.com" port="443" doc:name="HTTP Request Configuration"/>
    
       <spring:beans>
        <spring:bean name="getUserProfile" class="com.bitbucketflow.GetSparkUserProfile"/>
		</spring:beans>
    <db:mysql-config name="MYDB" host="192.168.1.163" port="3306" user="bandaru" password="sarasu10" database="sparkdb" doc:name="MySQL Configuration"/>
    <db:mysql-config name="MySQL_Configuration" host="192.168.1.163" port="3306" user="bandaru" password="sarasu10" database="sparkdb" doc:name="MySQL Configuration"/>
    <http:request-config name="HTTP_Request_Configuration2" host="192.168.1.168" port="8844" doc:name="HTTP Request Configuration"/>

    <flow name="Startintegration">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/startintegration" doc:name="HTTP"/>
        <set-variable variableName="action" value="#[message.inboundProperties.'http.query.params'.action]" doc:name="Action"/>
        <choice doc:name="Choice">
            <when expression="#[flowVars.action =='connect'|| flowVars.action =='list' || flowVars.action =='disconnect' ]">
                <db:select config-ref="MySQL_Configuration" doc:name="Database">
                    <db:dynamic-query><![CDATA[SELECT * FROM integrations_settings WHERE integration_id = #[message.inboundProperties.'http.query.params'.integration_id];]]></db:dynamic-query>
                </db:select>
                <logger message="lLLLLLLLLLLLLLLLLLLLLLLLLLLLL #[message.payload[0].setup_page_uri]" level="INFO" doc:name="Logger"/>
                <set-variable variableName="return_page_uri" value="#[message.payload[0].setup_page_uri]" doc:name="ReturnPage"/>
                <choice doc:name="Choice">
                    <when expression="#[flowVars.action =='connect']">
                        <expression-component doc:name="Get setup-page-uri"><![CDATA[flowVars.return_page_uri = message.payload[0].setup_page_uri;]]></expression-component>
                    </when>
                    <when expression="#[flowVars.action =='list']">
                        <expression-component doc:name="Get edit-page-uri"><![CDATA[flowVars.return_page_uri = message.payload[0].edit_page_uri;]]></expression-component>
                    </when>
                    <when expression="#[flowVars.action =='disconnect']">
                        <expression-component doc:name="Get delete-page-uri"><![CDATA[flowVars.return_page_uri = message.payload[0].delete_page_uri;]]></expression-component>
                    </when>
                </choice>
                <logger message="RETURN PAGE #[flowVars.return_page_uri]" level="INFO" doc:name="Logger"/>
                <http:request config-ref="HTTP_Request_Configuration" path="#[flowVars.return_page_uri].html" method="GET" doc:name="HTTP"/>
            </when>
            <otherwise>
                <http:request config-ref="HTTP_Request_Configuration" path="/examples/index.html" method="GET" doc:name="HTTP"/>
            </otherwise>
        </choice>
    </flow>
    
     <flow name="UserSettings">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/uisettings/*" doc:name="HTTP"/>
        <set-variable variableName="context" value="#[message.inboundProperties.'http.request.uri'.split(&quot;/&quot;)[2]]" doc:name="context"/>
        <set-variable variableName="integration_id" value="#[message.inboundProperties.'http.query.params'.integration_id]" doc:name="integration_id"/>
        <expression-component doc:name="Expression"><![CDATA[flowVars.context  =  flowVars.context.toString().split('\\?')[0];]]></expression-component>
        <set-variable variableName="token" value="#[message.inboundProperties.'http.query.params'.token]" doc:name="token"/>
        <CiscoSpark:get-people-detail config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.token]" doc:name="CiscoSpark"/>
        <logger message="EXCEPTIONNNNNNNNNNNNNNNNNNNNN #[flowVars.token]  ST #[payload.getId()] ID #[payload]" level="INFO" doc:name="Logger"/>
        <set-variable variableName="user_id" value="#[payload.getId()]" doc:name="user_id"/>
        <object-to-string-transformer doc:name="Object to String"/>
        <json:object-to-json-transformer doc:name="Object to JSON"/>
        <set-variable variableName="spark_user_profile" value="#[payload]" doc:name="spark_user_profile"/>
        <db:select config-ref="MySQL_Configuration" doc:name="Database">
            <db:parameterized-query><![CDATA[select access_token from auth_tokens where instance_id = #[flowVars.integration_id] and user_id = #[flowVars.user_id] and token_system = 'ZENDESK';]]></db:parameterized-query>
        </db:select>
        <set-variable variableName="zendesk_access_token" value="#[message.payload[0].access_token]" doc:name="zendesk_access_token"/>
        <logger message="#[flowVars.token] ST #[flowVars.user_id] UI #[flowVars.integration_id] ID #[flowVars.zendesk_access_token]" level="INFO" doc:name="Logger"/>
        <logger message="SPARK USER PROFILE #[flowVars.spark_user_profile]" level="INFO" doc:name="Logger"/>
        <choice doc:name="Choice">
            <when expression="#[flowVars.context =='zendesk']">
                <scatter-gather doc:name="Scatter-Gather">
                    <processor-chain>
                        <CiscoSpark:get-rooms config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.token]" doc:name="CiscoSpark"/>
                        <set-payload value="#[payload]" doc:name="Set Payload"/>
                    </processor-chain>
                    <processor-chain>
                        <invoke object-ref="getUserProfile" method="getSparkUserProfile" methodArguments="#[flowVars.token]" methodArgumentTypes="java.lang.String" doc:name="Invoke"/>
                        <object-to-string-transformer doc:name="Object to String"/>
                        <json:object-to-json-transformer doc:name="Object to JSON"/>
                        <set-payload value="{ &quot;profile&quot; : #[payload] }" doc:name="Set Payload"/>
                    </processor-chain>
                </scatter-gather>
            </when>
            <otherwise>
                <logger message="DEFAULT LOG" level="INFO" doc:name="Logger"/>
                <http:request config-ref="HTTP_Request_Configuration" path="/examples/index.html" method="GET" doc:name="HTTP"/>
            </otherwise>
        </choice>
        <set-payload value="#[payload]" doc:name="Set Payload"/>
        <json:object-to-json-transformer doc:name="Object to JSON"/>
        <logger level="INFO" doc:name="Logger" message="FINAL PAYLOAD #[payload]"/>
    </flow>
    
    
    <flow name="GetApplicationsDetailsFromIntegrationId">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/applications" doc:name="HTTP"/>
        <set-variable variableName="context" value="#[message.inboundProperties.'http.request.uri'.split(&quot;/&quot;)[1]]" doc:name="Variable"/>
        <expression-component doc:name="Expression"><![CDATA[flowVars.context  =  flowVars.context.toString().split('\\?')[0];]]></expression-component>
        <logger message="FLOS #[flowVars.context]" level="INFO" doc:name="Logger"/>
        <choice doc:name="Copy_of_Choice">
            <when expression="#[flowVars.context =='applications']">
                <db:select config-ref="MySQL_Configuration" doc:name="Database">
                    <db:parameterized-query><![CDATA[select authoriseurl,clientid,redirecturl,token_endpoint,token_validation_url,application_id,application_name,authorization_type,authorization_endpoint from applications where integration_id = #[message.inboundProperties.'http.query.params'.integration_id]]]></db:parameterized-query>
                </db:select>
                <logger message="PAYLOAD &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; #[payload.toString().replace('[','').replace(']','')]" level="INFO" doc:name="Logger"/>
                <collection-splitter doc:name="Collection Splitter"/>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <set-payload value="#[payload]" doc:name="Set Payload"/>
                <logger message="PAYLOAD &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;#[payload]" level="INFO" doc:name="Logger"/>
            </when>
            <otherwise>
                <logger message="DEFAULT LOG" level="INFO" doc:name="Logger"/>
                <http:request config-ref="HTTP_Request_Configuration" path="/examples/index.html" method="GET" doc:name="HTTP"/>
            </otherwise>
        </choice>
    </flow>
    
    
    <flow name="Save_Spark_Token">
       <http:listener config-ref="HTTP_Listener_Configuration" path="/savetokendetails" doc:name="HTTP"/>
       <set-variable variableName="token" value="#[message.inboundProperties.'http.query.params'.token]" doc:name="token"/>
        <CiscoSpark:get-people-detail config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.token]" doc:name="CiscoSpark"/>
        <set-variable variableName="user_id" value="#[payload.getId()]" doc:name="user_id"/>
        <db:insert config-ref="MySQL_Configuration" doc:name="Database Save Spark Token">
            <db:parameterized-query><![CDATA[insert into auth_tokens(instance_id,token_system,access_token,user_id) values('0000','SPARK',#[flowVars.token],#[flowVars.user_id]);]]></db:parameterized-query>
        </db:insert>
        <logger message="Database Result #[payload]" level="INFO" doc:name="Logger"/>
       <set-payload value="Saved Spark Token" doc:name="Set Payload"/>
   </flow>
    
    
     
    <flow name="GetAccess_Token_Zendesk">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/tokendetails/{}" doc:name="HTTP"/>
        <set-variable variableName="context" value="#[message.inboundProperties.'http.request.uri'.split(&quot;/&quot;)[2]]" doc:name="Context Root"/>
        <expression-component doc:name="Expression"><![CDATA[flowVars.context = flowVars.context.toString().split("\\?")[0];]]></expression-component>
        <logger message="SPLITTER : #[flowVars.context]" level="INFO" doc:name="Logger"/>
        <set-variable variableName="integration_id" value="#[message.inboundProperties.'http.query.params'.integration_id]" doc:name="integration_id"/>
        <set-variable variableName="token" value="#[message.inboundProperties.'http.query.params'.token]" doc:name="token"/>
        <set-variable variableName="code" value="#[message.inboundProperties.'http.query.params'.code]" doc:name="code"/>
        <CiscoSpark:get-people-detail config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.token]" doc:name="CiscoSpark"/>
        <set-variable variableName="user_id" value="#[payload.getId()]" doc:name="user_id"/>
        <logger message="tirapa #[payload.getId()]TIRAPA" level="INFO" doc:name="Logger"/>
        <db:select config-ref="MySQL_Configuration" doc:name="Database">
            <db:parameterized-query><![CDATA[select * from applications where integration_id=#[flowVars.integration_id]]]></db:parameterized-query>
        </db:select>
        <logger message="KUMER REDDY #[message.payload[0].clientid], #[message.payload[0].secretpwd] , #[message.payload[0].redirecturl]" level="INFO" doc:name="Logger"/>
        <choice doc:name="Choice">
            <when expression="#[(payload!=empty)&amp;&amp;(flowVars.context=='zendesk')]">
                <logger message="TTRLOGGER" level="INFO" doc:name="Logger"/>
               <set-variable variableName="code" value="#[flowVars.code]" doc:name="code"/>
        <set-variable variableName="client_id" value="#[message.payload[0].clientid]" doc:name="client_id"/>
        <set-variable variableName="client_secret" value="#[message.payload[0].secretpwd]" doc:name="client_secret"/>
        <set-variable variableName="redirect_uri" value="#[message.payload[0].redirecturl]" doc:name="redirect_uri"/>
        <set-variable variableName="domain" value="#['eidikohelp']" doc:name="domain"/>
        <set-payload value="#[{'client_id':flowVars.client_id, 'client_secret':flowVars.client_secret,'grant_type':'authorization_code','code':flowVars.code,'redirect_uri':flowVars.redirect_uri}]" doc:name="Set Payload"/>
        <logger message="#[payload]" level="INFO" doc:name="Logger"/>
        <http:request config-ref="HTTP_Request_Configuration1" path="/oauth/tokens" method="POST"   doc:name="HTTP" followRedirects="true" host="#[flowVars.domain].zendesk.com" port="443">
            <http:failure-status-code-validator values="500..599"/>
        </http:request>
        <byte-array-to-string-transformer returnClass="java.lang.String" doc:name="Byte Array to String"/>
        <logger message="#[payload]" level="INFO" doc:name="Logger"/>
        <set-payload value="#[payload]" mimeType="application/json" doc:name="Set Payload"/>
                <set-variable variableName="paylload" value="#[payload]" doc:name="payload"/>
                <set-variable variableName="access_token" value="#[json:access_token]" doc:name="access_token"/>
                <set-variable variableName="refresh_token" value="#[json:refresh_token]" doc:name="refresh_token"/>
                <logger message="#[payload] #[flowVars.integration_id],'BITBUCKET',#[json:access_token],#[json:refresh_token],#[function:now],#[function:now],#[flowVars.user_id] BITBUCKETTIRAPA" level="INFO" doc:name="Logger"/>
                <db:select config-ref="MySQL_Configuration" doc:name="Check Existinstance of the Bickbucket Token">
                    <db:parameterized-query><![CDATA[select access_token from auth_tokens where instance_id = #[flowVars.integration_id] and user_id = #[flowVars.user_id] and token_system = 'ZENDESK';]]></db:parameterized-query>
                </db:select>
                <logger message="BICKBUCKETTIRAPA #[payload!=empty] #[flowVars.access_token] #[flowVars.refresh_token]" level="INFO" doc:name="Logger"/>
                <choice doc:name="Choice">
                    <when expression="#[payload == empty]">
                        <db:insert config-ref="MySQL_Configuration" doc:name="Database Insert ZendeskToken Details">
                            <db:parameterized-query><![CDATA[insert into auth_tokens(token_id,instance_id,token_system,access_token,refresh_token,expires,refresh_expires,user_id) values(#[message.payload[0].uuid1],#[flowVars.integration_id],'ZENDESK',#[flowVars.access_token],#[flowVars.refresh_token],#[function:now],#[function:now],#[flowVars.user_id]);]]></db:parameterized-query>
                        </db:insert>
                        <logger message="INSERTED BITBUCKET DETAILS #[payload]" level="INFO" doc:name="Logger"/>
                    </when>
                    <when expression="#[payload !=empty]">
                        <db:update config-ref="MySQL_Configuration" doc:name="Database Update Zendesk">
                            <db:parameterized-query><![CDATA[update auth_tokens set access_token = #[flowVars.access_token], refresh_token = #[flowVars.refresh_token] where instance_id = #[flowVars.integration_id] and user_id = #[flowVars.user_id] and token_system = 'ZENDESK';]]></db:parameterized-query>
                        </db:update>
                        <logger message="UPDATEDD TOKEN DETAILS #[payload]" level="INFO" doc:name="Logger"/>
                    </when>
                </choice>
                <set-payload value="#[flowVars.paylload]" doc:name="Set Payload"/>
                <object-to-string-transformer doc:name="Object to String"/>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <logger message="PAYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY #[payload]" level="INFO" doc:name="Logger"/>
            </when>
            <when expression="">
                <set-payload value="invalid" doc:name="ID Not Found"/>
            </when>
        </choice>
    </flow>
    
    
      <flow name="Save">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/saveintegration/{}" allowedMethods="POST" doc:name="HTTP"/>
        <set-variable variableName="context" value="#[message.inboundProperties.'http.request.uri'.split(&quot;/&quot;)[2]]" doc:name="context"/>
        <set-variable variableName="id" value="#[json:integration_id]" doc:name="Integration_id"/>
        <set-variable variableName="user_id" value="#[json:user_id]" doc:name="user_id"/>
        <set-variable variableName="int_token" value="#[json:integration_token]" doc:name="int_token"/>
        <set-variable variableName="spark_token" value="#[json:spark_token]" doc:name="spark_token"/>
        <set-variable variableName="notification" value="#[json:config]" doc:name="notification"/>
        <set-variable variableName="room" value="#[json:room_id]" doc:name="room"/>
        <set-variable variableName="events" value="#[json:config/notifications]" doc:name="events"/>
        <logger message="EVENTS #[flowVars.events]" level="INFO" doc:name="Logger"/>
        <choice doc:name="Choice">
            <when expression="#[flowVars.context=='zendesk']">
                <db:select config-ref="MySQL_Configuration" doc:name="UUID">
                    <db:parameterized-query><![CDATA[select uuid() as "uuid";]]></db:parameterized-query>
                </db:select>
                <set-variable variableName="uuid1" value="#[message.payload[0].uuid]" doc:name="Variable"/>
                <logger message="#[message.payload[0].uuid]" level="INFO" doc:name="Logger"/>
                <db:insert config-ref="MySQL_Configuration" doc:name="INT TOKEN">
                    <db:parameterized-query><![CDATA[insert into auth_tokens (token_id,instance_id,token_system,access_token,expires,refresh_expires)
values(#[message.payload[0].uuid],#[flowVars.id],'ZENDESK',#[flowVars.int_token],#[function:now],#[function:now]);]]></db:parameterized-query>
                </db:insert>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <logger message="#[payload]" level="INFO" doc:name="Logger"/>
                <db:select config-ref="MySQL_Configuration" doc:name="UUID2">
                    <db:parameterized-query><![CDATA[select uuid() as "uuid2";]]></db:parameterized-query>
                </db:select>
                <logger message="#[message.payload[0].uuid2]" level="INFO" doc:name="Logger"/>
                <set-variable variableName="uuid2" value="#[message.payload[0].uuid2]" doc:name="Variable"/>
                <db:insert config-ref="MySQL_Configuration" doc:name="SPARK TOKEN">
                    <db:parameterized-query><![CDATA[insert into auth_tokens (token_id,instance_id,token_system,access_token)
values(#[message.payload[0].uuid2],#[flowVars.id],'SPARK',#[flowVars.spark_token]);]]></db:parameterized-query>
                </db:insert>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <logger message="#[payload]" level="INFO" doc:name="Logger"/>
                <db:select config-ref="MySQL_Configuration" doc:name="UUID3">
                    <db:parameterized-query><![CDATA[select uuid() as "uuid3";]]></db:parameterized-query>
                </db:select>
                <logger message="#[message.payload[0].uuid3]" level="INFO" doc:name="Logger"/>
                <db:insert config-ref="MySQL_Configuration" doc:name="insert_instances">
                    <db:parameterized-query><![CDATA[insert into integration_instances (instance_id,integration_id,config_json,status,created_date,spark_token_id,integration_token_id,channel_id,user_id) values(#[message.payload[0].uuid3],#[flowVars.id],#[flowVars.notification],'ACTIVE', #[function:now], #[flowVars.uuid2], #[flowVars.uuid1], #[flowVars.room],#[flowVars.user_id])]]></db:parameterized-query>
                </db:insert>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <logger message="before GET instance_ID : #[payload]" level="INFO" doc:name="Logger"/>
                <db:select config-ref="MySQL_Configuration" doc:name="get instance_id">
                    <db:parameterized-query><![CDATA[select instance_id from integration_instances where spark_token_id=#[flowVars.uuid2] AND integration_token_id=#[flowVars.uuid1]]]></db:parameterized-query>
                </db:select>
                <logger message="BEFORE GET_DOMAIN #[message.payload[0].instance_id]" level="INFO" doc:name="Logger"/>
                <set-variable variableName="instance_id" value="#[message.payload[0].instance_id]" doc:name="instance_id"/>
                <db:select config-ref="MySQL_Configuration" doc:name="Get Domain">
                    <db:parameterized-query><![CDATA[select value from config_details where webhookkey='WEBHOOKDOMAIN';]]></db:parameterized-query>
                </db:select>
                <logger message="AFTER DOMAIN" level="INFO" doc:name="Logger"/>
                <set-variable variableName="domain" value="#[message.payload[0].value]" doc:name="domain"/>
                <set-variable variableName="target_url" value="#[flowVars.domain + '/hooks/spark/zendesk/' +flowVars.instance_id]" doc:name="target_url"/>
                <logger message="TARGET URLLLLLLLLLLLLLLLLLLLLLLLLLLLLL #[flowVars.target_url]" level="INFO" doc:name="Logger"/>
                <set-payload value="{&quot;target&quot;: {&quot;type&quot;: &quot;http_target&quot;, &quot;title&quot;: &quot;EIDIKO-HELP-NOTIFICATION&quot;, &quot;target_url&quot;: &quot;#[flowVars.target_url]&quot;,&quot;method&quot;:&quot;post&quot;,&quot;content_type&quot;:&quot;application/json&quot;}}" doc:name="Set Payload"/>
                <http:request config-ref="HTTP_Request_Configuration1" path="/api/v2/targets.json" method="POST" host="eidikohelp.zendesk.com" port="443" doc:name="HTTP">
                    <http:request-builder>
                        <http:header headerName="Authorization" value="Bearer #[flowVars.int_token]"/>
                        <http:header headerName="Content-Type" value="application/json"/>
                    </http:request-builder>
                    <http:failure-status-code-validator values="500..599"/>
                </http:request>
                <logger message="TARGET PAYLOAD #[payload]" level="INFO" doc:name="Logger"/>
                <byte-array-to-string-transformer doc:name="Byte Array to String"/>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <set-variable variableName="target_id" value="#[json:target/id]" doc:name="target_id"/>
                <set-variable variableName="message_format" value="#['{&quot;status&quot;: &quot;{{ticket.status}}&quot;, &quot;id&quot;: &quot;{{ticket.id}}&quot;, &quot;updated_at&quot;: &quot;{{ticket.updated_at_with_timestamp}}&quot;,&quot;See The ling&quot;:&quot;{{ticket.link}}&quot;}']" doc:name="message_format"/>
                <set-payload value="{&quot;trigger&quot;: {&quot;title&quot;: &quot;EIDIKO-HELP-NOTIFICATION&quot;,&quot;actions&quot;: [{&quot;field&quot;: &quot;notification_target&quot;,&quot;value&quot;: [#[flowVars.target_id],&quot;The Ticket has been update&quot;]}],&quot;any&quot;: #[flowVars.events]}" doc:name="Set Payload"/>
                <logger message="TRIGGER #[payload]" level="INFO" doc:name="Logger"/>
                <http:request config-ref="HTTP_Request_Configuration1" path="api/v2/triggers.json" method="POST" host="eidikohelp.zendesk.com" port="443" doc:name="HTTP">
                    <http:request-builder>
                        <http:header headerName="Authorization" value="Bearer #[flowVars.int_token]"/>
                        <http:header headerName="Content-Type" value="application/json"/>
                    </http:request-builder>
                    <http:failure-status-code-validator values="500..599"/>
                </http:request>
                <byte-array-to-string-transformer doc:name="Byte Array to String"/>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <logger message="TRIGGER  PAYLOAD #[flowVars.instance_id],#[json:trigger/id],#[json:trigger/url],#[payload]" level="INFO" doc:name="Logger"/>
                <db:insert config-ref="MySQL_Configuration" doc:name="Stoke Webhook">
                    <db:parameterized-query><![CDATA[INSERT INTO webhook_details(instance_id,webhook_id,webhook_url,webhook_json) values(#[flowVars.instance_id],#[json:trigger/id],#[flowVars.target_url],#[payload]);]]></db:parameterized-query>
                </db:insert>
                <CiscoSpark:post-messages config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.spark_token]" doc:name="CiscoSpark">
                    <CiscoSpark:messages-post-request roomId="#[flowVars.room]" text="Added Zendesk  to this room!!"/>
                </CiscoSpark:post-messages>
            </when>
            <otherwise>
                <set-payload value="Invalid URL" doc:name="Set Payload"/>
            </otherwise>
        </choice>
    </flow>
    
    <flow name="Update">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/updateintegration/{}" allowedMethods="POST" doc:name="HTTP"/>
        <set-variable variableName="context" value="#[message.inboundProperties.'http.request.uri'.split(&quot;/&quot;)[2]]" doc:name="context"/>
        <set-variable variableName="id" value="#[json:integration_id]" doc:name="Integration_id"/>
        <set-variable variableName="instance_id" value="#[json:instance_id]" doc:name="instance_id"/>
        <set-variable variableName="user_id" value="#[json:user_id]" doc:name="user_id"/>
        <set-variable variableName="int_token" value="#[json:integration_token]" doc:name="int_token"/>
        <set-variable variableName="spark_token" value="#[json:spark_token]" doc:name="spark_token"/>
        <set-variable variableName="notification" value="#[json:config]" doc:name="notification"/>
        <set-variable variableName="room" value="#[json:room_id]" doc:name="room"/>
        <set-variable variableName="old_room" value="#[json:room_id_old]" doc:name="old_room"/>
        <set-variable variableName="events" value="#[json:config/notifications]" doc:name="events"/>
        <choice doc:name="Choice Room Change?">
            <when expression="#[flowVars.old_room != flowVars.room]">
                <logger message="The Room has been modified" level="INFO" doc:name="Logger"/>
                <CiscoSpark:post-messages config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.spark_token]" doc:name="CiscoSpark">
                    <CiscoSpark:messages-post-request roomId="#[flowVars.old_room]" text="This room has been deleted form zendesk configuration...........!"/>
                </CiscoSpark:post-messages>
                <CiscoSpark:post-messages config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.spark_token]" doc:name="CiscoSpark">
                    <CiscoSpark:messages-post-request roomId="#[flowVars.room]" text="This Room has been configured for Zendesk notifications!!!!!"/>
                </CiscoSpark:post-messages>
            </when>
            <otherwise>
                <logger message="Room not modified................!" level="INFO" doc:name="Logger"/>
            </otherwise>
        </choice>
        <logger message="EVENTS #[flowVars.events]" level="INFO" doc:name="Logger"/>
        <db:select config-ref="MySQL_Configuration" doc:name="Database">
            <db:dynamic-query><![CDATA[select webhook_id,webhook_json from webhook_details where instance_id = '#[flowVars.instance_id]';]]></db:dynamic-query>
        </db:select>
        <set-variable variableName="webhook_json" value="#[message.payload[0].webhook_json]" doc:name="webhook_json"/>
        <set-variable variableName="webhook_id" value="#[message.payload[0].webhook_id]" doc:name="webhook_id"/>
        <set-payload value="#[flowVars.webhook_json]" doc:name="Set Payload"/>
        <set-variable variableName="target_id" value="#[json:trigger/actions[0]/value]" doc:name="target_id"/>
        <logger message="TARGET ID #[flowVars.target_id] and WEBHOOKID  #[flowVars.webhook_id] " level="INFO" doc:name="Logger"/>
        <choice doc:name="Choice">
            <when expression="#[flowVars.context=='zendesk']">
                <set-payload value="{&quot;trigger&quot;: {&quot;title&quot;: &quot;EIDIKO-UPDATED-NOTIFICATION&quot;,&quot;actions&quot;: [{&quot;field&quot;: &quot;notification_target&quot;,&quot;value&quot;:  [#[flowVars.target_id],&quot;The Ticket has been update&quot;]}],&quot;any&quot;: #[flowVars.events]}" doc:name="Set Payload"/>
                <logger message="TRIGGER #[payload]" level="INFO" doc:name="Logger"/>
                <http:request config-ref="HTTP_Request_Configuration1" path="api/v2/triggers/#[flowVars.webhook_id]" method="PUT" host="eidikohelp.zendesk.com" port="443" doc:name="HTTP">
                    <http:request-builder>
                        <http:header headerName="Authorization" value="Bearer #[flowVars.int_token]"/>
                        <http:header headerName="Content-Type" value="application/json"/>
                    </http:request-builder>
                    <http:failure-status-code-validator values="500..599"/>
                </http:request>
                <byte-array-to-string-transformer doc:name="Byte Array to String"/>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <logger message="MODIFIED PAYLOAD #[payload]" level="INFO" doc:name="Logger"/>
                <db:update config-ref="MySQL_Configuration" doc:name="Update Integration instances">
                    <db:dynamic-query><![CDATA[update integration_instances set config_json = '#[flowVars.notification]',status = 'ACTIVE',updated_date='#[function:now]' ,channel_id = '#[flowVars.room]' where instance_id ='#[flowVars.instance_id]';]]></db:dynamic-query>
                </db:update>
                <logger message="#[payload] Updated Integration Instance" level="INFO" doc:name="Logger"/>
                <db:update config-ref="MySQL_Configuration" doc:name="Stoke Webhook">
                    <db:dynamic-query><![CDATA[update webhook_details set webhook_json ='#[flowVars.notification]' where instance_id = '#[flowVars.instance_id]';]]></db:dynamic-query>
                </db:update>
                <logger message="#[payload] Updated Webhooks" level="INFO" doc:name="Logger"/>
                <CiscoSpark:post-messages config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.spark_token]" doc:name="CiscoSpark">
                    <CiscoSpark:messages-post-request roomId="#[flowVars.room]" text="Updated Zendesk  configuration of this room with the following notificaitons  #[flowVars.events]"/>
                </CiscoSpark:post-messages>
            </when>
            <otherwise>
                <set-payload value="Invalid URL" doc:name="Set Payload"/>
            </otherwise>
        </choice>
    </flow>
    
    
    
    
    
    <flow name="ListInstances">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/listinstances/zendesk" doc:name="HTTP"/>
        <set-variable variableName="token" value="#[message.inboundProperties.'http.query.params'.token]" doc:name="token"/>
        <set-variable variableName="integration_id" value="#[message.inboundProperties.'http.query.params'.integration_id]" doc:name="integration_id"/>
        <CiscoSpark:get-people-detail config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.token]" doc:name="CiscoSpark"/>
        <set-variable variableName="user_id" value="#[payload.getId()]" doc:name="user_id"/>
        <logger message="#[flowVars.user_id]" level="INFO" doc:name="Logger"/>
        <db:select config-ref="MySQL_Configuration" doc:name="List_Instances">
            <db:parameterized-query><![CDATA[select I1.instance_id,integration_id,config_json,message_format,I1.user_id,channel_id,status,deleted,created_date,updated_date,a1.token_system as spark_token_system,a1.refresh_expires as spark_refresh_expires,a1.expires as spark_expires,a1.refresh_token as spark_refresh_token,a1.token_id as spark_token,a1.access_token as spark_access_token ,a2.token_system as int_token_system,a2.expires as int_expires,a2.refresh_token as int_refresh_token,a2.refresh_expires as int_refresh_expires,a2.token_id as int_token,a2.access_token as int_access_token from integration_instances I1, auth_tokens a1, auth_tokens a2 where  I1.integration_id =#[flowVars.integration_id] and I1.deleted="false" and I1.user_id=#[flowVars.user_id] and I1.spark_token_id=a1.token_id and I1.integration_token_id=a2.token_id;]]></db:parameterized-query>
        </db:select>
        <dw:transform-message metadata:id="c54953dd-f713-45bf-b1a4-a599ed689dd1" doc:name="Transform Message">
            <dw:set-payload><![CDATA[%dw 1.0
%output application/java
---
payload map ((payload01 , indexOfPayload01) -> {
	instanceId: payload01.instance_id,
	integrationId: payload01.integration_id,
	configJson: payload01.config_json as :string,
	messageFormat: payload01.message_format,
	userId: payload01.user_id,
	channelId: payload01.channel_id,
	status: payload01.status,
	createdDate: payload01.created_date as :string,
	//updatedDate: payload01.updated_date as :string,
	deleted: payload01.deleted,
	IntegrationToken: [{
		tokenId: payload01.int_token,
		expires: payload01.int_expires as :string,
		tokenSystem: payload01.int_token_system,
		accessToken: payload01.int_access_token,
		refreshToken: payload01.int_refresh_token,
		refreshExpires: payload01.int_refresh_expires as :string
	}],
	sparkToken: [{
		tokenId: payload01.spark_token,
		//expires: payload01.spark_expires as :string,
		tokenSystem: payload01.spark_token_system,
		accessToken: payload01.spark_access_token
		//refreshToken: payload01.spark_refresh_token,
		//refreshExpires: payload01.spark_refresh_expires as :string
	}]
})]]></dw:set-payload>
        </dw:transform-message>
        <logger message="#[payload]" level="INFO" doc:name="Logger"/>
        <json:object-to-json-transformer doc:name="Object to JSON"/>
        <logger message="AFETR JSON : #[payload]" level="INFO" doc:name="Logger"/>
    </flow>
    
    
     <flow name="Delete_instance">
       <http:listener config-ref="HTTP_Listener_Configuration" path="/deleteInstance" doc:name="HTTP"/>
       <set-variable variableName="instanceId" value="#[message.inboundProperties.'http.query.params'.instanceId]" doc:name="instanceId"/>
       <logger message="#[flowVars.instanceId]" level="INFO" doc:name="Logger"/>
       <db:select config-ref="MySQL_Configuration" doc:name="Get RoomId and Spark Access Token">
            <db:parameterized-query><![CDATA[select a1.channel_id as roomId, a2.access_token as token from integration_instances a1,auth_tokens a2 where a1.instance_id=#[flowVars.instanceId] and a2.token_id=a1.spark_token_id;]]></db:parameterized-query>
       </db:select>
        <choice doc:name="Choice">
            <when expression="#[(payload!=empty)]">
                <set-variable variableName="roomId" value="#[message.payload[0].roomId]" doc:name="RoomId"/>
                <set-variable variableName="token" value="#[message.payload[0].token]" doc:name="Access Token"/>
                <logger message="#[flowVars.roomId] AND #[flowVars.token]" level="INFO" doc:name="Logger"/>
                <db:update config-ref="MySQL_Configuration" doc:name="Update  Instance Status Deleted True">
                    <db:parameterized-query><![CDATA[update integration_instances set deleted='true' where instance_id=#[flowVars.instanceId]]]></db:parameterized-query>
                </db:update>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <logger message="#[payload]" level="INFO" doc:name="Logger"/>
                <db:select config-ref="MySQL_Configuration" doc:name="Database">
                    <db:dynamic-query><![CDATA[select webhook_id,webhook_json,webhook_url from webhook_details where instance_id = '#[flowVars.instanceId]';]]></db:dynamic-query>
                </db:select>
                <logger message="MESSAGE  #[payload]" level="INFO" doc:name="Logger"/>
                <set-variable variableName="webhook_id" value="#[message.payload[0].webhook_id]" doc:name="webhook_id"/>
                <set-variable variableName="webhook_url" value="#[message.payload[0].webhook_url]" doc:name="webhook_url"/>
                <set-payload value="#[message.payload[0].webhook_json]" doc:name="Set Payload"/>
                <json:object-to-json-transformer doc:name="Object to JSON"/>
                <set-variable variableName="full_name" value="#[json:subject/full_name]" doc:name="full_name"/>
                <CiscoSpark:get-people-detail config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.token]" doc:name="CiscoSpark"/>
                <set-variable variableName="user_id" value="#[payload.getId()]" doc:name="user_id"/>
                <db:select config-ref="MySQL_Configuration" doc:name="Database">
                    <db:parameterized-query><![CDATA[select * from auth_tokens where token_system='ZENDESK' and user_id= #[flowVars.user_id];]]></db:parameterized-query>
                </db:select>
                <set-variable variableName="zendesk_token" value="#[message.payload[0].access_token]" doc:name="zendesk_token"/>
                <set-variable variableName="delete_url_context" value="#['/api/v2/triggers/'+flowVars.webhook_id]    " doc:name="delete_url_context"/>
                <logger message="#['/api/v2/triggers/'+flowVars.webhook_id]    #[flowVars.delete_url_context]" level="INFO" doc:name="BBBBBBBBBBBBBBBBBBBBB"/>
                <set-payload value="#['{}']" mimeType="application/json" doc:name="Set Payload"/>
        <http:request config-ref="HTTP_Request_Configuration1" path="api/v2/triggers/#[flowVars.webhook_id]" method="DELETE" host="eidikohelp.zendesk.com" port="443" doc:name="HTTP">
            <http:request-builder>
                        <http:header headerName="Authorization" value="Bearer 640c4d61b924343cadfbda947aac3473f8ed479b57f37decb9bb06a7a85f2060"/>
                        <http:header headerName="Content-Type" value="application/json"/>
            </http:request-builder>
        </http:request>
        <byte-array-to-string-transformer doc:name="Byte Array to String"/>
        <json:object-to-json-transformer doc:name="Object to JSON"/>
        <logger message="#[payload]" level="INFO" doc:name="Logger"/>
                <logger message="DEPELETE WEBHOOK #[payload]" level="INFO" doc:name="Logger"/>
            </when>
            <otherwise>
                <logger message="NO DATA FOUND" level="INFO" doc:name="Logger"/>
            </otherwise>
        </choice>
       <CiscoSpark:post-messages config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.token]" doc:name="CiscoSpark">
           <CiscoSpark:messages-post-request roomId="#[flowVars.roomId]" text="#['Your Zendesk Instance has been deleted.']"/>
       </CiscoSpark:post-messages>
       <logger message="#[flowVars.roomId] AND #[flowVars.token]" level="INFO" doc:name="Logger"/>
   </flow>
    
   <flow name="RemoveAllInstances">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/zendesk/removeallinstances" doc:name="HTTP"/>
        <set-variable variableName="integration_id" value="#[message.inboundProperties.'http.query.params'.integration_id]" doc:name="integration_id"/>
        <set-variable variableName="token" value="#[message.inboundProperties.'http.query.params'.token]" doc:name="token"/>
        <CiscoSpark:get-people-detail config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.token]" doc:name="CiscoSpark Get People Details"/>
        <set-variable variableName="user_id" value="#[payload.getId()]" doc:name="user_id"/>
        <db:select config-ref="MySQL_Configuration" doc:name="List Instances From Integration_Instances">
            <db:dynamic-query><![CDATA[select * from integration_instances where integration_id = '#[flowVars.integration_id]' and user_id = '#[flowVars.user_id]' and deleted = "false";]]></db:dynamic-query>
        </db:select>
        <logger message="REMOVEALLA  #[payload]" level="INFO" doc:name="Logger"/>
        <foreach doc:name="For Each">
            <logger message="#[payload.instance_id] IN FOR EACH #[payload]" level="INFO" doc:name="Logger"/>
            <set-variable variableName="instance_id" value="#[payload.instance_id]" doc:name="instanceId"/>
            <http:request config-ref="HTTP_Request_Configuration2" path="/deleteInstance" method="GET" host="192.168.1.168" port="8844" doc:name="HTTP CALL DELETE INSTANCE ">
                <http:request-builder>
                    <http:query-param paramName="instanceId" value="#[flowVars.instance_id]"/>
                </http:request-builder>
            </http:request>
        </foreach>
    </flow>
    
    
    
    
    <flow name="Posting_Meaasges">
       <http:listener config-ref="HTTP_Listener_Configuration" path="/hooks/spark/zendesk/{id}" doc:name="HTTP"/>
       <set-variable variableName="instanceId" value="#[message.inboundProperties.'http.request.uri'.split(&quot;/&quot;)[4]]" doc:name="instanceId"/>
       <set-variable variableName="messageValue" value="#[payload]" doc:name="jsonOutput"/>
        <logger message="#[message.inboundProperties.'http.request.uri'.split(&quot;/&quot;)[4]] HHHHHHHHHHHHHH" level="INFO" doc:name="Logger"/>
       <db:select config-ref="MySQL_Configuration" doc:name="Database">
            <db:parameterized-query><![CDATA[select A.instance_id,integration_id,config_json,message_format,channel_id,status,spark_token_id,token_id,token_system,access_token from integration_instances I,auth_tokens A where
I.instance_id=#[flowVars.instanceId] and I.integration_id=A.instance_id and I.spark_token_id=A.token_id]]></db:parameterized-query>
       </db:select>
       <set-variable variableName="spark_access_token" value="#[message.payload[0].access_token]" doc:name="spark_token_id"/>
       <logger message="#[message.payload[0].access_token] TTTTTTTTTTTTTTTTT SPARK TOKEN ID" level="INFO" doc:name="Logger"/>
       <set-variable variableName="room_id" value="#[message.payload[0].channel_id]" doc:name="room_id"/>
       <logger message="#[message.payload[0].channel_id]  CHANNEL #[message.payload[0].token_id]" level="INFO" doc:name="Logger"/>
       <CiscoSpark:post-messages config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.spark_access_token]" doc:name="CiscoSpark">
           <CiscoSpark:messages-post-request roomId="#[message.payload[0].channel_id]" text="#[flowVars.messageValue]"/>
       </CiscoSpark:post-messages>
       <logger message="#[payload]" level="INFO" doc:name="Logger"/>
       <set-payload value="Sucess" doc:name="Set Payload"/>
   </flow>
    
     <flow name="DisconnectIntegrations">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/disconnectintegration" doc:name="HTTP"/>
        <set-variable variableName="integration_id" value="#[message.inboundProperties.'http.query.params'.integration_id]" doc:name="integration_id"/>
        <set-variable variableName="spark_token" value="#[message.inboundProperties.'http.query.params'.token]" doc:name="token"/>
        <CiscoSpark:get-people-detail config-ref="CiscoSpark__Configuration" token="Bearer #[flowVars.spark_token]" doc:name="CiscoSpark"/>
        <logger message="payload #[payload.getId()] Tirapa" level="INFO" doc:name="Logger"/>
        <set-variable variableName="user_id" value="#[payload.getId()]" doc:name="user_id"/>
        <db:delete config-ref="MySQL_Configuration" doc:name="Database">
            <db:parameterized-query><![CDATA[delete from auth_tokens where user_id = #[flowVars.user_id]  and token_system != 'SPARK' and instance_id=#[flowVars.integration_id]]]></db:parameterized-query>
        </db:delete>
        <logger message="#[payload]" level="INFO" doc:name="Logger"/>
    </flow>






</mule>
